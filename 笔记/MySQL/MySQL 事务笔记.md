# MySQL 事务笔记

## 目录
- [事务简介](#事务简介)
- [事务操作](#事务操作)
- [事务四大特性](#事务四大特性)
- [并发事务问题](#并发事务问题)
- [事务隔离级别](#事务隔离级别)
- [总结](#总结)
---

## 事务简介

事务（Transaction）是数据库操作的**逻辑单元**，由一组不可分割的SQL操作组成。主要用于保证：

- 多个操作的**原子性**（要么全部成功，要么全部失败）
- 维护数据一致性（例如：转账操作）

---

## 事务操作

```sql
-- 1. 开启事务
START TRANSACTION;  -- 或 BEGIN;

-- 2. 执行SQL操作
UPDATE account SET balance = balance - 100 WHERE id = 1;
UPDATE account SET balance = balance + 100 WHERE id = 2;

-- 3. 提交事务（确认执行）
COMMIT;

-- 4. 回滚事务（撤销操作）
ROLLBACK;

-- 5. 保存点（部分回滚）
SAVEPOINT point1;
ROLLBACK TO point1;
    
```

## （面试题）事务四大特性（ACID）

原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。 

一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。

（数据之和无论是否出现异常都不会改变）

隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立 环境下运行。

（AB并发运行时，A事务运行不会影响B事务的运行，B事务运行也同样不会影响A事务的运行，相当于二者都是在独立的环境下运行。）

持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。 

（无论事务是回滚还是提交，最后数据都会存储在磁盘里，所以它对数据库中的数据的改变就是永久的。 ）

上述就是事务的四大特性，简称ACID。

| 特性       | 描述                       | 实现机制            |
| ---------- | -------------------------- | ------------------- |
| **原子性** | 事务是不可分割的最小单元   | Undo Log            |
| **一致性** | 事务前后数据满足完整性约束 | 应用层 + 数据库约束 |
| **隔离性** | 并发事务互不干扰           | 锁机制 + MVCC       |
| **持久性** | 事务提交后永久生效         | Redo Log            |

------

## 并发事务问题

A，B是一对并发事务。
![请添加图片描述](https://i-blog.csdnimg.cn/direct/c144a23f1a524bbfa63e15ef3035e311.png)

1). 赃读：一个事务读到另外一个事务还没有提交的数据。
![](https://i-blog.csdnimg.cn/direct/bf4cf19352b34c24a52d0aaed006c40c.png)
假设有一个事务A，事务A要进行三个操作，然后他要一个一个的执行，第一个操作执行完了，再去执行第二个操作。假如说第一个操作执行的是select语句，第二个操作是执行update语句，注意事务没有完成的时候，事务是没有提交的，只有这个事务当中的操作完成之后，事务才会提交。那么此时我们再来看，事务A执行了第二步之后，他会把数据库中的表进行更新，那此时又有另外一个事务B，事务B他要进行的就是一个id=1查询操作，而此时刚好事务A对id为1的数据进行了更新，那么此时B事务就会把A更新后的事务拿到了，而此时A事务提交了吗?没有。（所以一个事务读到另外一个事务还没有提交的数据就称为脏读。）

**区别点**：B还没提交就读到了

2). 不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。
![](https://i-blog.csdnimg.cn/direct/a7e074bc22114b9bb2e95f5c3f09b3bf.png)
首先事务A有4步操作，首先第一步先去执行一个select id=1的语句，然后这时候B事务执行了一个update id=1的语句，并且提交了事务，此时A事务继续执行第三步，第三步又是一个查询语句且和第一条查询语句一模一样，那此时我们会发现第一次查询和第三次查询的结果确实不一样的，因为事务B执行了更新操作并且提交了。

事务A两次读取同一条记录，但是读取到的数据却是不一样的。

**区别点**：B提交之后A读到了，但是一次事务里两次同样的查询结果却不一致。

3). 幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据 已经存在，好像出现了 "幻影"。
![](https://i-blog.csdnimg.cn/direct/72cf73d72b364333a394bea991f2cf98.png)
事务A首先进行了一次id为1的查询操作，没有查到。然后这个时候事务B执行了插入操作，还没有提交。事务A接着执行插入操作，结果发现这个主键已经被占用了无法插入（主键冲突），转而去执行第三次查询id=1的数据的操作，因为此时事务B还没又提交，结果又发现数据库没有这条数据。（这种一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据 已经存在，好像出现了 "幻影"的现象，称为幻读。）

| 问题类型       | 现象描述                       | 示例场景                                             |
| -------------- | ------------------------------ | ---------------------------------------------------- |
| **脏读**       | 读到其他事务未提交的数据       | 事务A读到事务B修改后未提交的数据，B回滚后数据无效    |
| **不可重复读** | 同一事务内多次读取结果不同     | 事务A两次查询期间，事务B修改了数据并提交             |
| **幻读**       | 同一事务内多次查询返回不同行数 | 事务A查询时事务B插入/删除了符合条件的数据            |
| **丢失更新**   | 后提交覆盖先提交的修改         | 事务A和B同时修改同一数据，后提交的覆盖了先提交的结果 |

------

## 事务隔离级别（解决并发事务问题）

MySQL默认隔离级别：**Repeatable READ**

✅：会出现这种并发事务问题

❌：不会出现这种并发事务问题

tip：可以使用命令行模拟脏读 ，不可重复读 ，幻读现象。

| 隔离级别                        | 脏读 | 不可重复读 | 幻读 | 性能 | 使用场景       |
| ------------------------------- | ---- | ---------- | ---- | ---- | -------------- |
| **READ** uncommited（读未提交） | ✅    | ✅          | ✅    | 最高 | 极少使用       |
| **READ** commited（读已提交）   | ❌    | ✅          | ✅    | 较高 | Oracle默认     |
| **Repeatable READ**(可重复读)   | ❌    | ❌          | ✅    | 中等 | MySQL默认      |
| **Serializable**（串行化）      | ❌    | ❌          | ❌    | 最低 | 严格数据一致性 |

设置隔离级别：

```sql
-- 查看当前隔离级别
SELECT @@transaction_isolation;

-- 设置会话级隔离级别
SET SESSION TRANSACTION ISOLATION LEVEL (READ COMMITTED);

--注意：事务隔离级别越高，数据越安全，但是性能越低。 
```

------

## 总结

1. 事务简介

   事务是一组操作的集合，这组操作，要么全部执行成功，要么全部执行失败。

2. 事务操作

   START TRANSACTION；--开启事务
   COMMIT/ROLLBACK；--提交/回滚事务

3. 事务四大特性

   原子性(Atomicity)、一致性(Consistency）、隔离性(Isolation）、持久性(Durability )

4. 并发事务问题

   赃读、不可重复读、幻读

5. 事务隔离级别

   READ UNCOMMITTED、READ COMMITTED、REPEATABLE READ、SERIALIZABLE